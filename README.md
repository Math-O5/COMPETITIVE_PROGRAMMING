# CP - COMPETITIVE_PROGRAMMING

  Here are some resolutions of competitive programming. I like to do this problems to improve my skills coding, distract from the dayly tasks. Note, this code is really messy up, since is done only to be 'accepted".  

# Algorithms
<p>My implementations:</p>
<p>The link to the problem is commented insede the codes</p>
<ul>
    <li>
      <h2>DP - <a href="https://en.wikipedia.org/wiki/Dynamic_programming" target="_blank">Programming Dinamic</a></h2>
      <ul>
        <li><a href="ALGORITHMS/dp/range-sum.cpp" target="_blank">[1]</a> Range Sum</li>
        <li><a href="ALGORITHMS/dp/lis-dp.cpp" target="_blank">[1] </a> <a href="ALGORITHMS/dp/lis-bs.cpp">[2]</a> Longest Increase Sequence</li>
        <li><a href="ALGORITHMS/dp/wisp-dp.cpp" target="_blank">[1]</a> Weithed Interval Schedule Problem</li>
        <li><a href="ALGORITHMS/dp/wssp-dp.cpp" target="_blank">[1]</a> Knapsack</li>
        <li><a href="ALGORITHMS/dp/coin-dp.cpp" target="_blank">[1]</a> Coin Change</li>
      </ul>
      <h2>Pratice DP</h2>
      <ul>
          <li><a href="OTHERS/meu-troco.cpp">[1] </a><a href="OTHERS/meu-troco2.cpp">[2]</a><a href="OTHERS/meu-troco3.cpp">[3]</a> Véi, dá meu troco! - (DP - Coins)</li>
          <li><a href="OBI/2015/banco-inteligente.cpp">[1]</a><a href="UVA/357-let-count-the-ways.cpp">[2]</a> Formas de me dar meu dinheiro! (ways to count) (DP - Coin)</li>
          <li><a href="UVA/p507.cpp">[1]</a> UVA 507 Jill Rides Again - (DP - Sum Range)</li>
          <li><a href="OBI/2014/letra.cpp">[1]</a> OBI 2014 Letra - (DP - LIS)</li>
          <li><a href="UVA/p10543.cpp">[1]</a> UVA 10534 - Wavio Sequence (DP - LIS)</li>
          <li><a href="OBI/2007/pizza.cpp">[1]</a> OBI 2007 Pizza - (DP - Sum Range)</li>
          <li><a href="UVA/10131-is-bigger-smarter.cpp">[1] O(n²) </a><a href="UVA/10131-is-bigger-smarter2.cpp">[2] O(n log n)</a> UVA 10131 is bigger smarter?- (DP - LIS)</li>
          <li><a href="OTHERS/DNA-Sequence-Alignment.cpp">[1] O(n*m)</a> DNA Sequence Alignment (DP - String)</li>
          <li><a href="UVA/10616-divisible.cpp">[1] O(n²)</a>UVA 10616 Sum Divisble by n chosen m - (DP - Knapsack)</li>
      </ul>
    </li>
     <h2>Graph</h2>
      <ul>
        <li><a href="ALGORITHMS/graph/union-find.cpp" target="_blank">[1]</a> Union Find</li>
        <li><a href="ALGORITHMS/graph/dfs.cpp" target="_blank">[1]</a> DFS (Deep First Search)</li>
        <li><a href="ALGORITHMS/graph/bfs.cpp" target="_blank">[1]</a> BFS (Breadth First Search)</li>
        <li><a href="ALGORITHMS/graph/dijkstra.cpp" target="_blank">[1]</a> Dijkstra</li>
        <li><a href="ALGORITHMS/graph/prim.cpp" target="_blank">[1]</a> Prim's Algorithm</li>
        <li><a href="ALGORITHMS/graph/mst_fast_one.cpp" target="_blank">[1]</a><a href="ALGORITHMS/graph/mst_fast_one.cpp" target="_blank">[2]</a> MST (Minimum spanning  - Kruskal)</li>
        <li><a href="ALGORITHMS/graph/ordenacao-topologica.cpp" target="_blank">[BFS]</a><a href="ALGORITHMS/graph/ordenacao-topologica-2.cpp" target="_blank">[DFS]</a> versão da Ordenação Topologica (Top Sorting)</li>
        <li><a href="ALGORITHMS/graph/bellman-ford.cpp" target="_blank">[O(|V|*|E|)]</a>Bellforman Ford (Min Path)</li>
      </ul>
      <h2>Pratice Graphs</h2>
      <ul>
          <li><a href="OBI/2010/fusões.cpp">[1]</a><a href="OTHERS/guildas.cpp">[2]</a> OBI Fusões - Guildas (Graph - Union Find)</li>
          <li><a href="CODEFORCES/c-new-distribution.cpp">[1]</a> CODEFORCES 69 - C - new Distribution (Graph - DFS or Union Find)</li>
          <li><a href="OBI/2016/taco_do_saci.cpp">[1]</a> OBI 2016 - Taco do Saci (Graph - DFS)</li>
          <li><a href="OBI/2011/escalonamento.cpp">[1] O(|V| + |E|)</a> OBI 2011 - Escalonamento Ótimo (Graph - Ordenação Topológica)</li>
          <li><a href="UVA/558-Wormholes.cpp">[1] O(|V| + |E|)</a> UVA 558 - Wormholes (Graph - Negative Cycles)</li>  
      </ul>
    <li>
      <h2>DATA STRUCTURE</h2>
      <ul>
        <li><a href="ALGORITHMS/struct/stl-1.md" target="_blank">[1]</a> STL 1 (vector, queue, stack, pair)</li>
        <li><a href="ALGORITHMS/struct/stl-2.md" target="_blank">[1]</a> STL 1 (vector, queue, stack, pair)</li>
        <li><a href="ALGORITHMS/struct/stl-3.md" target="_blank">[1]</a> STL 1 (vector, queue, stack, pair)</li>
        <li><a href="ALGORITHMS/struct/bs.md" target="_blank">[1]</a> Binary Search Tree</li>
        <li><a href="ALGORITHMS/struct/segTree.cpp" target="_blank">[1]</a> Segmented tree (seg Tree)</li>
      </ul>
      <h2>Pratice</h2>
      <ul>
        <li><a href="UVA/p540_team_queue.cpp" target="_blank">[1]</a> UVA 540 Team Queue (Map)</li>
        <li><a href="UVA/p837.cpp" target="_blank">[1]</a> UVA 837 Light and Transparencies (Map, Set)</li>
        <li><a href="OBI/2012/banco.cpp" target="_blank">[1]</a> OBI Banco (Priority Queue)</li>
        <li><a href="OBI/2012/soma-de-casas-2.cpp" target="_blank">[1]U(n log n)</a> OBI Banco (Binary Search)</li>
      </ul>
    </li>
</ul>
